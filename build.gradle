// build.gradle (master)

/**
 * MIT License
 * Copyright (c) 2017 kkdt
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Applying top-level java plugin but the root project is not really a java project,
 * its sub projects are java library projects. This is configured so that eclipse
 * can generate a single-project view from the root baseline.
 */
apply plugin : 'java'

group = 'kkdt'
version = '0.1'
description = "Various useful Gradle tasks"

ext {
   projectLib = file(rootProject.projectDir.path + '/lib')
   localLib = projectLib
}

jar {
   destinationDir = localLib
}

allprojects {
   apply plugin : 'eclipse'
   
   eclipse {
      classpath {
         downloadSources = true
      }
   }

   repositories {
      jcenter()
   }

   task info(description:'Use information about project (' + project.name + ')') {
      doLast {
         // https://docs.gradle.org/current/dsl/org.gradle.api.Project.html
         println '-----> user.home               : ' + System.properties['user.home']
         println '-----> project.name            : ' + project.name
         println '-----> project.version         : ' + project.version
         println '-----> project.projectDir      : ' + project.projectDir
         println '-----> project.buildDir        : ' + project.buildDir
         // not indented for visual formatting
         if(project.plugins.hasPlugin('java')) {
         println '-----> (java) archivesBaseName : ' + archivesBaseName
         println '-----> (java) jar.archivePath  : ' + jar.archivePath
         println '-----> (java) libsDir          : ' + libsDir
         println '-----> (java) libsDirName      : ' + libsDirName
         println '-----> (java) distsDir         : ' + distsDir
         println '-----> (java) distsDirName     : ' + distsDirName
         }
      }
   }
   
   task cleanAll(description:'Clean all custom artifacts', dependsOn:['clean']) {
      doLast {
         delete jar.archivePath
      }
   }
}

subprojects {
   // Define eclipse-specific configurations so that root project knows to
   // process them during eclipse plugin tasks
   configurations {
      eclipseLibs {
         description 'All library dependencies for subproject'
      }

      eclipseSources {
         description 'All source directories for subproject'
      }
   }
}

eclipse {
   classpath {
      file.whenMerged { classpath ->
         // subproject jar files will be ignored
         def archives = subprojects.findAll { project ->
            project.plugins.hasPlugin('java') && project.name != rootProject.name
         }.collect { project ->
            project.jar.archivePath
         }.collect() as Set

         subprojects.findAll { project ->
            project.plugins.hasPlugin('java') && project.name != rootProject.name
         }.collect { project ->
            project.configurations.eclipseSources.each {
               if(file(it).exists()) {
                  def src = new org.gradle.plugins.ide.eclipse.model.SourceFolder(rootProject.relativePath(it.absolutePath), null)
                  classpath.entries += src
               }
            }
         }

         subprojects.findAll { project ->
            project.plugins.hasPlugin('java') && project.name != rootProject.name
         }.collect { project ->
            project.configurations.eclipseLibs.each {
               def fileRef = fileReference(it)
               def lib = new org.gradle.plugins.ide.eclipse.model.Library(fileRef)
               lib.exported = true

               if(!classpath.entries.contains(lib) && !archives.contains(fileRef.file)) {
                  classpath.entries += lib
               }
            }
         }
      }
   }
}
